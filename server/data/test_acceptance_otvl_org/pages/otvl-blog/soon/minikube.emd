<div otvl-web>
type: sf_q_img_in_card
src: /assets/images/minikube/portVendresMk8s.jpg
alt: Article image
title: Vers Port Vendres mk8s
</div>

# Installing Minikube on Debian buster KVM

![logo work in progess](/assets/images/common/wip.png "Logo work in progress")

** Preview: ** this is a work in progress.

## Introduction
    
As mentioned on its project's page:

_Minikube implements a local Kubernetes cluster on macOS, Linux, and Windows.
Minikube's primary goals are to be the best tool for local Kubernetes application development
and to support all Kubernetes features that fit._

This article details the various steps for the installation of Minikube
on a development workstation under Debian 10 "buster"
running the
[KVM](https://wiki.debian.org/KVM)
hypervisor.

## Components architecture

To be completed.

## Installation steps

The installation takes place on the KVM host machine.
Make sure your system is up-to-date and backups are correct.

In the following sections

- command lines starting with `"# "` are run by root,
- command lines starting with `"$ "` are run by the login of the developer,
- output of commands is displayed without prefix,
- comments are displayed with `"## "` prefix.

First we install kubectl and check its installation.

    :::text
    # apt-get install curl
    # curl -LO https://storage.googleapis.com/kubernetes-release/release/`curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt`/bin/linux/amd64/kubectl
    # chmod +x kubectl
    # mv ./kubectl /usr/local/bin/kubectl
    # kubectl version --client
    Client Version: version.Info{Major:"1", Minor:"18", GitVersion:"v1.18.4", ..., Platform:"linux/amd64"}

&nbsp;  
Next we install minikube and check its installation.

    :::text
    # curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 \
        && chmod +x minikube
    # mv ./minikube /usr/local/bin/minikube
    # minikube version
    minikube version: v1.11.0
    commit: 57e2f55f47effe9ce396cea42a1e0eb4f611ebbd

&nbsp;  
If we want to access a GPU from the Kubernetes cluster,
we need to enable
[IOMMU](https://en.wikipedia.org/wiki/Input%E2%80%93output_memory_management_unit)
support in the BIOS and in the Linux kernel. Type the following:

    :::text
    virt-host-validate

If the previous command reported IOMMU as not supported,
we have to check the BIOS and configure the Linux boot
by updating the GRUB boot loader configuration:

    :::text
    # vi /etc/default/grub
    ## change the line containing GRUB_CMDLINE_LINUX_DEFAULT by adding intel_iommu (or amd)
    GRUB_CMDLINE_LINUX_DEFAULT="quiet intel_iommu=on"
    
    # update-grub

Next we have to reboot the system.

Now we may install and start a Kubernetes cluster.
If we need to access a GPU from the Kubernetes cluster,
we will provide the option `--kvm-gpu=true` below.
We first check the virsh configuration, then create and launch a Kubernetes cluster,
and finally check its state.

    :::text
    $ virsh --connect qemu:///system version
    $ minikube start --driver=kvm2 [--kvm-gpu=true]
    outputs with emojis here...
    $ minikube status
    minikube
    type: Control Plane
    host: Running
    kubelet: Running
    apiserver: Running
    kubeconfig: Configured

&nbsp;  
We may then stop the cluster.

    :::text
    minikube stop

## What happened?

If we check our KVM domains configuration, we will see:

- a new VM named "minikube" with the same hostname
- it has 2 CPUs, 3720 MiB RAM and a virtual disk of 20GB
- it has a (NETWORK TBC)

## References

- [minikube project](https://github.com/kubernetes/minikube)
- [minikube installation](https://kubernetes.io/docs/tasks/tools/install-minikube/)
- [minikube KVM2 driver](https://minikube.sigs.k8s.io/docs/drivers/kvm2/)

